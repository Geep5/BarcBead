{
  "version": 3,
  "sources": ["../node_modules/@noble/secp256k1/index.js", "../node_modules/@noble/hashes/src/crypto.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/_md.ts", "../node_modules/@noble/hashes/src/sha2.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../src/lib/nostr.js", "../src/background.js"],
  "sourcesContent": ["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 5KB JS implementation of secp256k1 ECDSA / Schnorr signatures & ECDH.\n * Compliant with RFC6979 & BIP340.\n * @module\n */\n/**\n * Curve params. secp256k1 is short weierstrass / koblitz curve. Equation is y\u00B2 == x\u00B3 + ax + b.\n * * P = `2n**256n-2n**32n-2n**977n` // field over which calculations are done\n * * N = `2n**256n - 0x14551231950b75fc4402da1732fc9bebfn` // group order, amount of curve points\n * * h = `1n` // cofactor\n * * a = `0n` // equation param\n * * b = `7n` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst secp256k1_CURVE = {\n    p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,\n    n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,\n    h: 1n,\n    a: 0n,\n    b: 7n,\n    Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,\n    Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,\n};\nconst { p: P, n: N, Gx, Gy, b: _b } = secp256k1_CURVE;\nconst L = 32; // field / group byte length\nconst L2 = 64;\nconst lengths = {\n    publicKey: L + 1,\n    publicKeyUncompressed: L2 + 1,\n    signature: L2,\n    seed: L + L / 2,\n};\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\nconst captureTrace = (...args) => {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n};\nconst err = (message = '') => {\n    const e = new Error(message);\n    captureTrace(e, err);\n    throw e;\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** Asserts something is Uint8Array. */\nconst abytes = (value, length, title = '') => {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        err(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n};\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined, consider polyfill');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst arange = (n, min, max, msg = 'bad number: out of range') => isBig(n) && min <= n && n < max ? n : err(msg);\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using eucledian GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = hashes[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst hash = (msg) => callHash('sha256')(msg);\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\n/** secp256k1 formula. Koblitz curves are subclass of weierstrass curves with a=0, making it x\u00B3+b */\nconst koblitz = (x) => M(M(x * x) * x + _b);\n/** assert is element of field mod P (incl. 0) */\nconst FpIsValid = (n) => arange(n, 0n, P);\n/** assert is element of field mod P (excl. 0) */\nconst FpIsValidNot0 = (n) => arange(n, 1n, P);\n/** assert is element of field mod N (excl. 0) */\nconst FnIsValidNot0 = (n) => arange(n, 1n, N);\nconst isEven = (y) => (y & 1n) === 0n;\n/** create Uint8Array of byte n */\nconst u8of = (n) => Uint8Array.of(n);\nconst getPrefix = (y) => u8of(isEven(y) ? 0x02 : 0x03);\n/** lift_x from BIP340 calculates square root. Validates x, then validates root*root. */\nconst lift_x = (x) => {\n    // Let c = x\u00B3 + 7 mod p. Fail if x \u2265 p. (also fail if x < 1)\n    const c = koblitz(FpIsValidNot0(x));\n    // c = \u221Ay\n    // y = c^((p+1)/4) mod p\n    // This formula works for fields p = 3 mod 4 -- a special, fast case.\n    // Paper: \"Square Roots from 1;24,51,10 to Dan Shanks\".\n    let r = 1n;\n    for (let num = c, e = (P + 1n) / 4n; e > 0n; e >>= 1n) {\n        // powMod: modular exponentiation.\n        if (e & 1n)\n            r = (r * num) % P; // Uses exponentiation by squaring.\n        num = (num * num) % P; // Not constant-time.\n    }\n    return M(r * r) === c ? r : err('sqrt invalid'); // check if result is valid\n};\n/** Point in 3d xyz projective coordinates. 3d takes less inversions than 2d. */\nclass Point {\n    static BASE;\n    static ZERO;\n    X;\n    Y;\n    Z;\n    constructor(X, Y, Z) {\n        this.X = FpIsValid(X);\n        this.Y = FpIsValidNot0(Y); // Y can't be 0 in Projective\n        this.Z = FpIsValid(Z);\n        Object.freeze(this);\n    }\n    static CURVE() {\n        return secp256k1_CURVE;\n    }\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(ap) {\n        const { x, y } = ap;\n        return x === 0n && y === 0n ? I : new Point(x, y, 1n);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromBytes(bytes) {\n        abytes(bytes);\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        let p = undefined;\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        const x = sliceBytesNumBE(tail, 0, L);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            // Equation is y\u00B2 == x\u00B3 + ax + b. We calculate y from x.\n            // y = \u221Ay\u00B2; there are two solutions: y, -y. Determine proper solution based on prefix\n            let y = lift_x(x);\n            const evenY = isEven(y);\n            const evenH = isEven(big(head));\n            if (evenH !== evenY)\n                y = M(-y);\n            p = new Point(x, y, 1n);\n        }\n        // Uncompressed 65-byte point, 0x04 prefix\n        if (length === uncomp && head === 0x04)\n            p = new Point(x, sliceBytesNumBE(tail, L, L2), 1n);\n        // Validate point\n        return p ? p.assertValidity() : err('bad point: not on curve');\n    }\n    static fromHex(hex) {\n        return Point.fromBytes(hexToBytes(hex));\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(this.X, M(-this.Y), this.Z);\n    }\n    /** Point doubling: P+P, complete formula. */\n    double() {\n        return this.add(this);\n    }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.\n     */\n    // prettier-ignore\n    add(other) {\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = apoint(other);\n        const a = 0n;\n        const b = _b;\n        let X3 = 0n, Y3 = 0n, Z3 = 0n;\n        const b3 = M(b * 3n);\n        let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1); // step 1\n        let t4 = M(X2 + Y2); // step 5\n        t3 = M(t3 * t4);\n        t4 = M(t0 + t1);\n        t3 = M(t3 - t4);\n        t4 = M(X1 + Z1);\n        let t5 = M(X2 + Z2); // step 10\n        t4 = M(t4 * t5);\n        t5 = M(t0 + t2);\n        t4 = M(t4 - t5);\n        t5 = M(Y1 + Z1);\n        X3 = M(Y2 + Z2); // step 15\n        t5 = M(t5 * X3);\n        X3 = M(t1 + t2);\n        t5 = M(t5 - X3);\n        Z3 = M(a * t4);\n        X3 = M(b3 * t2); // step 20\n        Z3 = M(X3 + Z3);\n        X3 = M(t1 - Z3);\n        Z3 = M(t1 + Z3);\n        Y3 = M(X3 * Z3);\n        t1 = M(t0 + t0); // step 25\n        t1 = M(t1 + t0);\n        t2 = M(a * t2);\n        t4 = M(b3 * t4);\n        t1 = M(t1 + t2);\n        t2 = M(t0 - t2); // step 30\n        t2 = M(a * t2);\n        t4 = M(t4 + t2);\n        t0 = M(t1 * t4);\n        Y3 = M(Y3 + t0);\n        t0 = M(t5 * t4); // step 35\n        X3 = M(t3 * X3);\n        X3 = M(X3 - t0);\n        t0 = M(t3 * t1);\n        Z3 = M(t5 * Z3);\n        Z3 = M(Z3 + t0); // step 40\n        return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(apoint(other).negate());\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && n === 0n)\n            return I;\n        FnIsValidNot0(n);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    multiplyUnsafe(scalar) {\n        return this.multiply(scalar, false);\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z) \u220B (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { X: x, Y: y, Z: z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 0n };\n        if (z === 1n)\n            return { x, y };\n        const iz = invert(z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(z * iz) !== 1n)\n            err('inverse invalid');\n        // x = X*Z^-1; y = Y*Z^-1\n        return { x: M(x * iz), y: M(y * iz) };\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const { x, y } = this.toAffine(); // convert to 2d xy affine point.\n        FpIsValidNot0(x); // must be in range 1 <= x,y < P\n        FpIsValidNot0(y);\n        // y\u00B2 == x\u00B3 + ax + b, equation sides must be equal\n        return M(y * y) === koblitz(x) ? this : err('bad point: not on curve');\n    }\n    /** Converts point to 33/65-byte Uint8Array. */\n    toBytes(isCompressed = true) {\n        const { x, y } = this.assertValidity().toAffine();\n        const x32b = numTo32b(x);\n        if (isCompressed)\n            return concatBytes(getPrefix(y), x32b);\n        return concatBytes(u8of(0x04), x32b, numTo32b(y));\n    }\n    toHex(isCompressed) {\n        return bytesToHex(this.toBytes(isCompressed));\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n);\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\n/** `Q = u1\u22C5G + u2\u22C5R`. Verifies Q is not ZERO. Unsafe: non-CT. */\nconst doubleScalarMulUns = (R, u1, u2) => {\n    return G.multiply(u1, false).add(R.multiply(u2, false)).assertValidity();\n};\nconst bytesToNumBE = (b) => big('0x' + (bytesToHex(b) || '0'));\nconst sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));\nconst B256 = 2n ** 256n; // secp256k1 is weierstrass curve. Equation is x\u00B3 + ax + b.\n/** Number to 32b. Must be 0 <= num < B256. validate, pad, to bytes. */\nconst numTo32b = (num) => hexToBytes(padh(arange(num, 0n, B256), L2));\n/** Normalize private key to scalar (bigint). Verifies scalar is in range 1<s<N */\nconst secretKeyToScalar = (secretKey) => {\n    const num = bytesToNumBE(abytes(secretKey, L, 'secret key'));\n    return arange(num, 1n, N, 'invalid secret key: outside of range');\n};\n/** For Signature malleability, validates sig.s is bigger than N/2. */\nconst highS = (n) => n > N >> 1n;\n/** Creates 33/65-byte public key from 32-byte private key. */\nconst getPublicKey = (privKey, isCompressed = true) => {\n    return G.multiply(secretKeyToScalar(privKey)).toBytes(isCompressed);\n};\nconst isValidSecretKey = (secretKey) => {\n    try {\n        return !!secretKeyToScalar(secretKey);\n    }\n    catch (error) {\n        return false;\n    }\n};\nconst isValidPublicKey = (publicKey, isCompressed) => {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n        const l = publicKey.length;\n        if (isCompressed === true && l !== comp)\n            return false;\n        if (isCompressed === false && l !== publicKeyUncompressed)\n            return false;\n        return !!Point.fromBytes(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n};\nconst assertRecoveryBit = (recovery) => {\n    if (![0, 1, 2, 3].includes(recovery))\n        err('recovery id must be valid and present');\n};\nconst assertSigFormat = (format) => {\n    if (format != null && !ALL_SIG.includes(format))\n        err(`Signature format must be one of: ${ALL_SIG.join(', ')}`);\n    if (format === SIG_DER)\n        err('Signature format \"der\" is not supported: switch to noble-curves');\n};\nconst assertSigLength = (sig, format = SIG_COMPACT) => {\n    assertSigFormat(format);\n    const SL = lengths.signature;\n    const RL = SL + 1;\n    let msg = `Signature format \"${format}\" expects Uint8Array with length `;\n    if (format === SIG_COMPACT && sig.length !== SL)\n        err(msg + SL);\n    if (format === SIG_RECOVERED && sig.length !== RL)\n        err(msg + RL);\n};\n/** ECDSA Signature class. Supports only compact 64-byte representation, not DER. */\nclass Signature {\n    r;\n    s;\n    recovery;\n    constructor(r, s, recovery) {\n        this.r = FnIsValidNot0(r); // 1 <= r < N\n        this.s = FnIsValidNot0(s); // 1 <= s < N\n        if (recovery != null)\n            this.recovery = recovery;\n        Object.freeze(this);\n    }\n    static fromBytes(b, format = SIG_COMPACT) {\n        assertSigLength(b, format);\n        let rec;\n        if (format === SIG_RECOVERED) {\n            rec = b[0];\n            b = b.subarray(1);\n        }\n        const r = sliceBytesNumBE(b, 0, L);\n        const s = sliceBytesNumBE(b, L, L2);\n        return new Signature(r, s, rec);\n    }\n    addRecoveryBit(bit) {\n        return new Signature(this.r, this.s, bit);\n    }\n    hasHighS() {\n        return highS(this.s);\n    }\n    toBytes(format = SIG_COMPACT) {\n        const { r, s, recovery } = this;\n        const res = concatBytes(numTo32b(r), numTo32b(s));\n        if (format === SIG_RECOVERED) {\n            assertRecoveryBit(recovery);\n            return concatBytes(Uint8Array.of(recovery), res);\n        }\n        return res;\n    }\n}\n/**\n * RFC6979: ensure ECDSA msg is X bytes, convert to BigInt.\n * RFC suggests optional truncating via bits2octets.\n * FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits,\n * which matches bits2int. bits2int can produce res>N.\n */\nconst bits2int = (bytes) => {\n    const delta = bytes.length * 8 - 256;\n    if (delta > 1024)\n        err('msg invalid'); // our CUSTOM check, \"just-in-case\": prohibit long inputs\n    const num = bytesToNumBE(bytes);\n    return delta > 0 ? num >> big(delta) : num;\n};\n/** int2octets can't be used; pads small msgs with 0: BAD for truncation as per RFC vectors */\nconst bits2int_modN = (bytes) => modN(bits2int(abytes(bytes)));\n// todo: better name\nconst SIG_COMPACT = 'compact';\nconst SIG_RECOVERED = 'recovered';\nconst SIG_DER = 'der';\nconst ALL_SIG = [SIG_COMPACT, SIG_RECOVERED, SIG_DER];\nconst defaultSignOpts = {\n    lowS: true,\n    prehash: true,\n    format: SIG_COMPACT,\n    extraEntropy: false,\n};\nconst _sha = 'SHA-256';\nconst hashes = {\n    hmacSha256Async: async (key, message) => {\n        const s = subtle();\n        const name = 'HMAC';\n        const k = await s.importKey('raw', key, { name, hash: { name: _sha } }, false, ['sign']);\n        return u8n(await s.sign(name, k, message));\n    },\n    hmacSha256: undefined,\n    sha256Async: async (msg) => u8n(await subtle().digest(_sha, msg)),\n    sha256: undefined,\n};\nconst prepMsg = (msg, opts, async_) => {\n    abytes(msg, undefined, 'message');\n    if (!opts.prehash)\n        return msg;\n    return async_ ? hashes.sha256Async(msg) : callHash('sha256')(msg);\n};\nconst NULL = u8n(0);\nconst byte0 = u8of(0x00);\nconst byte1 = u8of(0x01);\nconst _maxDrbgIters = 1000;\nconst _drbgErr = 'drbg: tried max amount of iterations';\n// HMAC-DRBG from NIST 800-90. Minimal, non-full-spec - used for RFC6979 signatures.\nconst hmacDrbg = (seed, pred) => {\n    let v = u8n(L); // Steps B, C of RFC6979 3.2: set hashLen\n    let k = u8n(L); // In our case, it's always equal to L\n    let i = 0; // Iterations counter, will throw when over max\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n    };\n    // h = hmac(K || V || ...)\n    const h = (...b) => callHash('hmacSha256')(k, concatBytes(v, ...b));\n    const reseed = (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    // HMAC-DRBG generate() function\n    const gen = () => {\n        if (i++ >= _maxDrbgIters)\n            err(_drbgErr);\n        v = h(); // v = hmac(k || v)\n        return v; // this diverges from noble-curves: we don't allow arbitrary output len!\n    };\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen())))\n        reseed(); // test predicate until it returns ok\n    reset();\n    return res;\n};\n// Identical to hmacDrbg, but async: uses built-in WebCrypto\nconst hmacDrbgAsync = async (seed, pred) => {\n    let v = u8n(L); // Steps B, C of RFC6979 3.2: set hashLen\n    let k = u8n(L); // In our case, it's always equal to L\n    let i = 0; // Iterations counter, will throw when over max\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n    };\n    // h = hmac(K || V || ...)\n    const h = (...b) => hashes.hmacSha256Async(k, concatBytes(v, ...b));\n    const reseed = async (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = await h(byte0, seed); // k = hmac(K || V || 0x00 || seed)\n        v = await h(); // v = hmac(K || V)\n        if (seed.length === 0)\n            return;\n        k = await h(byte1, seed); // k = hmac(K || V || 0x01 || seed)\n        v = await h(); // v = hmac(K || V)\n    };\n    // HMAC-DRBG generate() function\n    const gen = async () => {\n        if (i++ >= _maxDrbgIters)\n            err(_drbgErr);\n        v = await h(); // v = hmac(K || V)\n        return v; // this diverges from noble-curves: we don't allow arbitrary output len!\n    };\n    reset();\n    await reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(await gen())))\n        await reseed(); // test predicate until it returns ok\n    reset();\n    return res;\n};\n// RFC6979 signature generation, preparation step.\n// Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.2 & RFC6979.\nconst _sign = (messageHash, secretKey, opts, hmacDrbg) => {\n    let { lowS, extraEntropy } = opts; // generates low-s sigs by default\n    // RFC6979 3.2: we skip step A\n    const int2octets = numTo32b; // int to octets\n    const h1i = bits2int_modN(messageHash); // msg bigint\n    const h1o = int2octets(h1i); // msg octets\n    const d = secretKeyToScalar(secretKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), h1o]; // Step D of RFC6979 3.2\n    /** RFC6979 3.6: additional k' (optional). See {@link ECDSAExtraEntropy}. */\n    if (extraEntropy != null && extraEntropy !== false) {\n        // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n        // gen random bytes OR pass as-is\n        const e = extraEntropy === true ? randomBytes(L) : extraEntropy;\n        seedArgs.push(abytes(e, undefined, 'extraEntropy')); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = h1i; // convert msg to bigint\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k\u22C5G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    const k2sig = (kBytes) => {\n        // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n        // Important: all mod() calls here must be done over N\n        const k = bits2int(kBytes);\n        if (!(1n <= k && k < N))\n            return; // Valid scalars (including k) must be in 1..N-1\n        const ik = invert(k, N); // k^-1 mod n\n        const q = G.multiply(k).toAffine(); // q = k\u22C5G\n        const r = modN(q.x); // r = q.x mod n\n        if (r === 0n)\n            return;\n        const s = modN(ik * modN(m + r * d)); // s = k^-1(m + rd) mod n\n        if (s === 0n)\n            return;\n        let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n); // recovery bit (2 or 3, when q.x > n)\n        let normS = s; // normalized S\n        if (lowS && highS(s)) {\n            // if lowS was passed, ensure s is always\n            normS = modN(-s); // in the bottom half of CURVE.n\n            recovery ^= 1;\n        }\n        const sig = new Signature(r, normS, recovery); // use normS, not s\n        return sig.toBytes(opts.format);\n    };\n    return hmacDrbg(seed, k2sig);\n};\n// Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.4.\nconst _verify = (sig, messageHash, publicKey, opts = {}) => {\n    const { lowS, format } = opts;\n    if (sig instanceof Signature)\n        err('Signature must be in Uint8Array, use .toBytes()');\n    assertSigLength(sig, format);\n    abytes(publicKey, undefined, 'publicKey');\n    try {\n        const { r, s } = Signature.fromBytes(sig, format);\n        const h = bits2int_modN(messageHash); // Truncate hash\n        const P = Point.fromBytes(publicKey); // Validate public key\n        if (lowS && highS(s))\n            return false; // lowS bans sig.s >= CURVE.n/2\n        const is = invert(s, N); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = doubleScalarMulUns(P, u1, u2).toAffine(); // R = u1\u22C5G + u2\u22C5P\n        // Stop if R is identity / zero point. Check is done inside `doubleScalarMulUns`\n        const v = modN(R.x); // R.x must be in N's field, not P's\n        return v === r; // mod(R.x, n) == r\n    }\n    catch (error) {\n        return false;\n    }\n};\nconst setDefaults = (opts) => {\n    const res = {};\n    Object.keys(defaultSignOpts).forEach((k) => {\n        // @ts-ignore\n        res[k] = opts[k] ?? defaultSignOpts[k];\n    });\n    return res;\n};\n/**\n * Sign a message using secp256k1. Sync: uses `hashes.sha256` and `hashes.hmacSha256`.\n * Prehashes message with sha256, disable using `prehash: false`.\n * @param opts - see {@link ECDSASignOpts} for details. Enabling {@link ECDSAExtraEntropy} will improve security.\n * @example\n * ```js\n * const msg = new TextEncoder().encode('hello noble');\n * sign(msg, secretKey);\n * sign(keccak256(msg), secretKey, { prehash: false });\n * sign(msg, secretKey, { extraEntropy: true });\n * sign(msg, secretKey, { format: 'recovered' });\n * ```\n */\nconst sign = (message, secretKey, opts = {}) => {\n    opts = setDefaults(opts);\n    message = prepMsg(message, opts, false);\n    return _sign(message, secretKey, opts, hmacDrbg);\n};\n/**\n * Sign a message using secp256k1. Async: uses built-in WebCrypto hashes.\n * Prehashes message with sha256, disable using `prehash: false`.\n * @param opts - see {@link ECDSASignOpts} for details. Enabling {@link ECDSAExtraEntropy} will improve security.\n * @example\n * ```js\n * const msg = new TextEncoder().encode('hello noble');\n * await signAsync(msg, secretKey);\n * await signAsync(keccak256(msg), secretKey, { prehash: false });\n * await signAsync(msg, secretKey, { extraEntropy: true });\n * await signAsync(msg, secretKey, { format: 'recovered' });\n * ```\n */\nconst signAsync = async (message, secretKey, opts = {}) => {\n    opts = setDefaults(opts);\n    message = await prepMsg(message, opts, true);\n    return _sign(message, secretKey, opts, hmacDrbgAsync);\n};\n/**\n * Verify a signature using secp256k1. Sync: uses `hashes.sha256` and `hashes.hmacSha256`.\n * @param signature - default is 64-byte 'compact' format, also see {@link ECDSASignatureFormat}\n * @param message - message which was signed. Keep in mind `prehash` from opts.\n * @param publicKey - public key which\n * @param opts - see {@link ECDSAVerifyOpts} for details.\n * @example\n * ```js\n * const msg = new TextEncoder().encode('hello noble');\n * verify(sig, msg, publicKey);\n * verify(sig, keccak256(msg), publicKey, { prehash: false });\n * verify(sig, msg, publicKey, { lowS: false });\n * verify(sigr, msg, publicKey, { format: 'recovered' });\n * ```\n */\nconst verify = (signature, message, publicKey, opts = {}) => {\n    opts = setDefaults(opts);\n    message = prepMsg(message, opts, false);\n    return _verify(signature, message, publicKey, opts);\n};\n/**\n * Verify a signature using secp256k1. Async: uses built-in WebCrypto hashes.\n * @param signature - default is 64-byte 'compact' format, also see {@link ECDSASignatureFormat}\n * @param message - message which was signed. Keep in mind `prehash` from opts.\n * @param publicKey - public key which\n * @param opts - see {@link ECDSAVerifyOpts} for details.\n * @example\n * ```js\n * const msg = new TextEncoder().encode('hello noble');\n * verify(sig, msg, publicKey);\n * verify(sig, keccak256(msg), publicKey, { prehash: false });\n * verify(sig, msg, publicKey, { lowS: false });\n * verify(sigr, msg, publicKey, { format: 'recovered' });\n * ```\n */\nconst verifyAsync = async (sig, message, publicKey, opts = {}) => {\n    opts = setDefaults(opts);\n    message = await prepMsg(message, opts, true);\n    return _verify(sig, message, publicKey, opts);\n};\nconst _recover = (signature, messageHash) => {\n    const sig = Signature.fromBytes(signature, 'recovered');\n    const { r, s, recovery } = sig;\n    // 0 or 1 recovery id determines sign of \"y\" coordinate.\n    // 2 or 3 means q.x was >N.\n    assertRecoveryBit(recovery);\n    const h = bits2int_modN(abytes(messageHash, L)); // Truncate hash\n    const radj = recovery === 2 || recovery === 3 ? r + N : r;\n    FpIsValidNot0(radj); // ensure q.x is still a field element\n    const head = getPrefix(big(recovery)); // head is 0x02 or 0x03\n    const Rb = concatBytes(head, numTo32b(radj)); // concat head + r\n    const R = Point.fromBytes(Rb);\n    const ir = invert(radj, N); // r^-1\n    const u1 = modN(-h * ir); // -hr^-1\n    const u2 = modN(s * ir); // sr^-1\n    const point = doubleScalarMulUns(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n    return point.toBytes();\n};\n/**\n * ECDSA public key recovery. Requires msg hash and recovery id.\n * Follows [SEC1](https://secg.org/sec1-v2.pdf) 4.1.6.\n */\nconst recoverPublicKey = (signature, message, opts = {}) => {\n    message = prepMsg(message, setDefaults(opts), false);\n    return _recover(signature, message);\n};\nconst recoverPublicKeyAsync = async (signature, message, opts = {}) => {\n    message = await prepMsg(message, setDefaults(opts), true);\n    return _recover(signature, message);\n};\n/**\n * Elliptic Curve Diffie-Hellman (ECDH) on secp256k1.\n * Result is **NOT hashed**. Use hash or KDF on it if you need.\n * @param isCompressed 33-byte (true) or 65-byte (false) output\n * @returns public key C\n */\nconst getSharedSecret = (secretKeyA, publicKeyB, isCompressed = true) => {\n    return Point.fromBytes(publicKeyB).multiply(secretKeyToScalar(secretKeyA)).toBytes(isCompressed);\n};\n// FIPS 186 B.4.1 compliant key generation produces private keys\n// with modulo bias being neglible. takes >N+16 bytes, returns (hash mod n-1)+1\nconst randomSecretKey = (seed = randomBytes(lengths.seed)) => {\n    abytes(seed);\n    if (seed.length < lengths.seed || seed.length > 1024)\n        err('expected 40-1024b');\n    const num = M(bytesToNumBE(seed), N - 1n);\n    return numTo32b(num + 1n);\n};\nconst createKeygen = (getPublicKey) => (seed) => {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n};\nconst keygen = createKeygen(getPublicKey);\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    concatBytes: concatBytes,\n    bytesToNumberBE: bytesToNumBE,\n    numberToBytesBE: numTo32b,\n    mod: M,\n    invert: invert, // math utilities\n    randomBytes: randomBytes,\n    secretKeyToScalar: secretKeyToScalar,\n    abytes: abytes,\n};\n/** Curve-specific utilities for private keys. */\nconst utils = {\n    isValidSecretKey: isValidSecretKey,\n    isValidPublicKey: isValidPublicKey,\n    randomSecretKey: randomSecretKey,\n};\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst getTag = (tag) => Uint8Array.from('BIP0340/' + tag, (c) => c.charCodeAt(0));\nconst T_AUX = 'aux';\nconst T_NONCE = 'nonce';\nconst T_CHALLENGE = 'challenge';\nconst taggedHash = (tag, ...messages) => {\n    const fn = callHash('sha256');\n    const tagH = fn(getTag(tag));\n    return fn(concatBytes(tagH, tagH, ...messages));\n};\nconst taggedHashAsync = async (tag, ...messages) => {\n    const fn = hashes.sha256Async;\n    const tagH = await fn(getTag(tag));\n    return await fn(concatBytes(tagH, tagH, ...messages));\n};\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\n// Calculate point, scalar and bytes\nconst extpubSchnorr = (priv) => {\n    const d_ = secretKeyToScalar(priv);\n    const p = G.multiply(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n    const { x, y } = p.assertValidity().toAffine(); // validate Point is not at infinity\n    const d = isEven(y) ? d_ : modN(-d_);\n    const px = numTo32b(x);\n    return { d, px };\n};\nconst bytesModN = (bytes) => modN(bytesToNumBE(bytes));\nconst challenge = (...args) => bytesModN(taggedHash(T_CHALLENGE, ...args));\nconst challengeAsync = async (...args) => bytesModN(await taggedHashAsync(T_CHALLENGE, ...args));\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nconst pubSchnorr = (secretKey) => {\n    return extpubSchnorr(secretKey).px; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n};\nconst keygenSchnorr = createKeygen(pubSchnorr);\n// Common preparation fn for both sync and async signing\nconst prepSigSchnorr = (message, secretKey, auxRand) => {\n    const { px, d } = extpubSchnorr(secretKey);\n    return { m: abytes(message), px, d, a: abytes(auxRand, L) };\n};\nconst extractK = (rand) => {\n    const k_ = bytesModN(rand); // Let k' = int(rand) mod n\n    if (k_ === 0n)\n        err('sign failed: k is zero'); // Fail if k' = 0.\n    const { px, d } = extpubSchnorr(numTo32b(k_)); // Let R = k'\u22C5G.\n    return { rx: px, k: d };\n};\n// Common signature creation helper\nconst createSigSchnorr = (k, px, e, d) => {\n    return concatBytes(px, numTo32b(modN(k + e * d)));\n};\nconst E_INVSIG = 'invalid signature produced';\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nconst signSchnorr = (message, secretKey, auxRand = randomBytes(L)) => {\n    const { m, px, d, a } = prepSigSchnorr(message, secretKey, auxRand);\n    const aux = taggedHash(T_AUX, a);\n    // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const t = numTo32b(d ^ bytesToNumBE(aux));\n    // Let rand = hash/nonce(t || bytes(P) || m)\n    const rand = taggedHash(T_NONCE, t, px, m);\n    const { rx, k } = extractK(rand);\n    // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const e = challenge(rx, px, m);\n    const sig = createSigSchnorr(k, rx, e, d);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!verifySchnorr(sig, m, px))\n        err(E_INVSIG);\n    return sig;\n};\nconst signSchnorrAsync = async (message, secretKey, auxRand = randomBytes(L)) => {\n    const { m, px, d, a } = prepSigSchnorr(message, secretKey, auxRand);\n    const aux = await taggedHashAsync(T_AUX, a);\n    // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const t = numTo32b(d ^ bytesToNumBE(aux));\n    // Let rand = hash/nonce(t || bytes(P) || m)\n    const rand = await taggedHashAsync(T_NONCE, t, px, m);\n    const { rx, k } = extractK(rand);\n    // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const e = await challengeAsync(rx, px, m);\n    const sig = createSigSchnorr(k, rx, e, d);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!(await verifySchnorrAsync(sig, m, px)))\n        err(E_INVSIG);\n    return sig;\n};\nconst callSyncAsyncFn = (res, later) => {\n    return res instanceof Promise ? res.then(later) : later(res);\n};\nconst _verifSchnorr = (signature, message, publicKey, challengeFn) => {\n    const sig = abytes(signature, L2, 'signature');\n    const msg = abytes(message, undefined, 'message');\n    const pub = abytes(publicKey, L, 'publicKey');\n    try {\n        // lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n        // Fail if x \u2265 p. Let c = x\u00B3 + 7 mod p.\n        const x = bytesToNumBE(pub);\n        const y = lift_x(x); // Let y = c^(p+1)/4 mod p.\n        const y_ = isEven(y) ? y : M(-y);\n        // Return the unique point P such that x(P) = x and\n        // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n        const P_ = new Point(x, y_, 1n).assertValidity();\n        const px = numTo32b(P_.toAffine().x);\n        // P = lift_x(int(pk)); fail if that fails\n        const r = sliceBytesNumBE(sig, 0, L); // Let r = int(sig[0:32]); fail if r \u2265 p.\n        arange(r, 1n, P);\n        const s = sliceBytesNumBE(sig, L, L2); // Let s = int(sig[32:64]); fail if s \u2265 n.\n        arange(s, 1n, N);\n        const i = concatBytes(numTo32b(r), px, msg);\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        return callSyncAsyncFn(challengeFn(i), (e) => {\n            const { x, y } = doubleScalarMulUns(P_, s, modN(-e)).toAffine(); // R = s\u22C5G - e\u22C5P\n            if (!isEven(y) || x !== r)\n                return false; // -eP == (n-e)P\n            return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n        });\n    }\n    catch (error) {\n        return false;\n    }\n};\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nconst verifySchnorr = (s, m, p) => _verifSchnorr(s, m, p, challenge);\nconst verifySchnorrAsync = async (s, m, p) => _verifSchnorr(s, m, p, challengeAsync);\nconst schnorr = {\n    keygen: keygenSchnorr,\n    getPublicKey: pubSchnorr,\n    sign: signSchnorr,\n    verify: verifySchnorr,\n    signAsync: signSchnorrAsync,\n    verifyAsync: verifySchnorrAsync,\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8, NOT 32 - see wNAF loop\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        // We use negative indexes to reduce size of precomputed table by 2x.\n        // Instead of needing precomputes 0..256, we only calculate them for 0..128.\n        // If an index > 128 is found, we do (256-index) - where 256 is next window.\n        // Naive: index +127 => 127, +224 => 224\n        // Optimized: index +127 => 127, +224 => 256-32\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        }\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    if (n !== 0n)\n        err('invalid wnaf');\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export below to easily use in REPL / browser console\nexport { etc, getPublicKey, getSharedSecret, hash, hashes, keygen, Point, recoverPublicKey, recoverPublicKeyAsync, schnorr, sign, signAsync, Signature, utils, verify, verifyAsync };\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "// Nostr implementation using @noble/secp256k1 for cryptography\n// Uses basic Nostr protocol: NIP-01 for events, custom tags for URL channels\n\nimport * as secp from '@noble/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { hmac } from '@noble/hashes/hmac';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\n\n// Configure secp256k1 to use sha256 from noble/hashes (required in v3)\nsecp.etc.hmacSha256Sync = (k, ...m) => hmac(sha256, k, secp.etc.concatBytes(...m));\nsecp.etc.sha256Sync = (...m) => sha256(secp.etc.concatBytes(...m));\n// Also set on hashes object for Schnorr signatures\nif (secp.hashes) {\n  secp.hashes.sha256 = sha256;\n  secp.hashes.hmacSha256 = (key, msg) => hmac(sha256, key, msg);\n}\n\nconst DEFAULT_RELAYS = [\n  'wss://relay.damus.io',\n  'wss://nos.lol',\n  'wss://relay.primal.net'\n];\n\n// Generate a random private key (32 bytes hex)\nfunction generatePrivateKey() {\n  return bytesToHex(randomBytes(32));\n}\n\n// Derive public key from private key (x-only, 32 bytes hex)\nfunction getPublicKey(privateKeyHex) {\n  const privateKeyBytes = hexToBytes(privateKeyHex);\n  const pubkeyBytes = secp.getPublicKey(privateKeyBytes, true); // compressed\n  // Return x-coordinate only (skip the 02/03 prefix byte)\n  return bytesToHex(pubkeyBytes.slice(1));\n}\n\n// SHA256 hash of a string, returns hex\nasync function sha256Hex(message) {\n  const msgBytes = new TextEncoder().encode(message);\n  return bytesToHex(sha256(msgBytes));\n}\n\n// SHA256 hash of bytes, returns bytes\nfunction sha256Bytes(bytes) {\n  return sha256(bytes);\n}\n\n// Create and sign a Nostr event\nasync function createEvent(privateKey, kind, content, tags = []) {\n  const pubkey = getPublicKey(privateKey);\n  const created_at = Math.floor(Date.now() / 1000);\n\n  // NIP-01: Event ID is sha256 of serialized [0, pubkey, created_at, kind, tags, content]\n  const eventData = [0, pubkey, created_at, kind, tags, content];\n  const serialized = JSON.stringify(eventData);\n  const id = await sha256Hex(serialized);\n\n  // Sign the event ID with Schnorr signature (both must be Uint8Array)\n  const sig = await secp.schnorr.sign(hexToBytes(id), hexToBytes(privateKey));\n\n  const event = {\n    id,\n    pubkey,\n    created_at,\n    kind,\n    tags,\n    content,\n    sig: bytesToHex(sig)\n  };\n\n  // Verify our own signature before sending (for debugging)\n  const isValid = await secp.schnorr.verify(sig, hexToBytes(id), hexToBytes(pubkey));\n  if (!isValid) {\n    console.error('Self-verification failed! Event:', event);\n  }\n\n  return event;\n}\n\n// Verify a Schnorr signature on a Nostr event\nasync function verifySignature(event) {\n  try {\n    const { id, pubkey, sig } = event;\n    return await secp.schnorr.verify(hexToBytes(sig), hexToBytes(id), hexToBytes(pubkey));\n  } catch (error) {\n    console.error('Signature verification error:', error);\n    return false;\n  }\n}\n\n// NIP-04: Encrypted Direct Messages\n// Uses ECDH to derive shared secret, then AES-256-CBC\n\nasync function nip04Encrypt(privateKeyHex, recipientPubKeyHex, plaintext) {\n  // Compute shared point using ECDH\n  // For NIP-04, we need to add the 02 prefix to make it a valid compressed pubkey\n  const recipientPubkeyFull = '02' + recipientPubKeyHex;\n  const sharedPoint = secp.getSharedSecret(privateKeyHex, recipientPubkeyFull);\n  // Use x-coordinate as shared secret (skip first byte which is the prefix)\n  const sharedSecret = sharedPoint.slice(1, 33);\n\n  // Generate random IV (16 bytes)\n  const iv = crypto.getRandomValues(new Uint8Array(16));\n\n  // Import shared secret as AES key\n  const key = await crypto.subtle.importKey(\n    'raw',\n    sharedSecret,\n    { name: 'AES-CBC' },\n    false,\n    ['encrypt']\n  );\n\n  // Encrypt\n  const plaintextBytes = new TextEncoder().encode(plaintext);\n  const ciphertext = await crypto.subtle.encrypt(\n    { name: 'AES-CBC', iv },\n    key,\n    plaintextBytes\n  );\n\n  // Format: base64(ciphertext)?iv=base64(iv)\n  const ciphertextB64 = btoa(String.fromCharCode(...new Uint8Array(ciphertext)));\n  const ivB64 = btoa(String.fromCharCode(...iv));\n\n  return `${ciphertextB64}?iv=${ivB64}`;\n}\n\nasync function nip04Decrypt(privateKeyHex, senderPubKeyHex, encryptedContent) {\n  // Compute shared point using ECDH\n  const senderPubkeyFull = '02' + senderPubKeyHex;\n  const sharedPoint = secp.getSharedSecret(privateKeyHex, senderPubkeyFull);\n  const sharedSecret = sharedPoint.slice(1, 33);\n\n  // Parse format: base64(ciphertext)?iv=base64(iv)\n  const [ciphertextB64, ivPart] = encryptedContent.split('?iv=');\n  if (!ivPart) throw new Error('Invalid NIP-04 format');\n\n  const ciphertext = Uint8Array.from(atob(ciphertextB64), c => c.charCodeAt(0));\n  const iv = Uint8Array.from(atob(ivPart), c => c.charCodeAt(0));\n\n  // Import shared secret as AES key\n  const key = await crypto.subtle.importKey(\n    'raw',\n    sharedSecret,\n    { name: 'AES-CBC' },\n    false,\n    ['decrypt']\n  );\n\n  // Decrypt\n  const plaintextBytes = await crypto.subtle.decrypt(\n    { name: 'AES-CBC', iv },\n    key,\n    ciphertext\n  );\n\n  return new TextDecoder().decode(plaintextBytes);\n}\n\n// URL to channel ID - hash the normalized URL\nasync function urlToChannelId(url) {\n  try {\n    const parsed = new URL(url);\n    // Normalize: remove hash, some query params, trailing slashes\n    const normalized = parsed.origin + parsed.pathname.replace(/\\/$/, '');\n    return await sha256Hex(normalized);\n  } catch {\n    return await sha256Hex(url);\n  }\n}\n\n// Nostr relay connection manager\nclass NostrRelay {\n  constructor(url) {\n    this.url = url;\n    this.ws = null;\n    this.subscriptions = new Map();\n    this.connected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.eventCallbacks = new Map();\n    this.eoseCallbacks = new Map();\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        if (!this.connected) {\n          console.warn(`Connection timeout for relay: ${this.url}`);\n          reject(new Error('Connection timeout'));\n        }\n      }, 5000);\n\n      try {\n        this.ws = new WebSocket(this.url);\n\n        this.ws.onopen = () => {\n          clearTimeout(timeout);\n          this.connected = true;\n          this.reconnectAttempts = 0;\n          console.log(`Connected to relay: ${this.url}`);\n          resolve();\n        };\n\n        this.ws.onclose = () => {\n          clearTimeout(timeout);\n          this.connected = false;\n          console.log(`Disconnected from relay: ${this.url}`);\n          this.attemptReconnect();\n        };\n\n        this.ws.onerror = (error) => {\n          clearTimeout(timeout);\n          console.error(`Relay error (${this.url}):`, error);\n          reject(error);\n        };\n\n        this.ws.onmessage = (msg) => {\n          this.handleMessage(msg.data);\n        };\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      setTimeout(() => this.connect().catch(() => {}), 2000 * this.reconnectAttempts);\n    }\n  }\n\n  handleMessage(data) {\n    try {\n      const msg = JSON.parse(data);\n      const [type, ...rest] = msg;\n\n      if (type === 'EVENT') {\n        const [subId, event] = rest;\n        const callback = this.eventCallbacks.get(subId);\n        if (callback) {\n          callback(event);\n        }\n      } else if (type === 'EOSE') {\n        const [subId] = rest;\n        const eoseCallback = this.eoseCallbacks.get(subId);\n        if (eoseCallback) {\n          eoseCallback();\n          this.eoseCallbacks.delete(subId);\n        }\n      } else if (type === 'OK') {\n        const [eventId, success, message] = rest;\n        console.log(`[${this.url}] Event ${eventId.slice(0, 8)}: ${success ? 'published' : 'REJECTED'} - ${message || ''}`);\n      }\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  }\n\n  subscribe(subId, filters, callback, onEose = null) {\n    if (!this.connected) return;\n\n    this.eventCallbacks.set(subId, callback);\n    if (onEose) {\n      this.eoseCallbacks.set(subId, onEose);\n    }\n    const msg = JSON.stringify(['REQ', subId, ...filters]);\n    this.ws.send(msg);\n    this.subscriptions.set(subId, filters);\n  }\n\n  unsubscribe(subId) {\n    if (!this.connected) return;\n\n    this.eventCallbacks.delete(subId);\n    this.subscriptions.delete(subId);\n    const msg = JSON.stringify(['CLOSE', subId]);\n    this.ws.send(msg);\n  }\n\n  publish(event) {\n    if (!this.connected) return false;\n\n    const msg = JSON.stringify(['EVENT', event]);\n    this.ws.send(msg);\n    return true;\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}\n\n// Main Nostr client for Barc\nclass BarcNostrClient {\n  constructor() {\n    this.relays = [];\n    this.privateKey = null;\n    this.publicKey = null;\n    this.currentChannelId = null;\n    this.currentUrl = null;\n    this.messageCallback = null;\n    this.presenceCallback = null;\n    this.globalActivityCallback = null;\n    this.dmCallback = null;\n    this.users = new Map();\n    this.dmConversations = new Map();\n    this.globalActivity = new Map();\n    this.seenMessageIds = new Set();\n    this.pendingMessages = [];\n  }\n\n  async init(savedPrivateKey = null) {\n    if (savedPrivateKey) {\n      this.privateKey = savedPrivateKey;\n    } else {\n      this.privateKey = generatePrivateKey();\n    }\n    this.publicKey = getPublicKey(this.privateKey);\n\n    const connectionPromises = DEFAULT_RELAYS.map(async (url) => {\n      const relay = new NostrRelay(url);\n      try {\n        await relay.connect();\n        this.relays.push(relay);\n        console.log(`Successfully connected to ${url}`);\n        return true;\n      } catch (error) {\n        console.warn(`Failed to connect to ${url}:`, error);\n        return false;\n      }\n    });\n\n    await Promise.allSettled(connectionPromises);\n    console.log(`Connected to ${this.relays.filter(r => r.connected).length}/${DEFAULT_RELAYS.length} relays`);\n\n    this.subscribeToGlobalActivity();\n    this.subscribeToDMs();\n\n    return { privateKey: this.privateKey, publicKey: this.publicKey };\n  }\n\n  subscribeToDMs() {\n    const filters = [\n      {\n        kinds: [4],\n        '#p': [this.publicKey],\n        since: Math.floor(Date.now() / 1000) - 86400\n      },\n      {\n        kinds: [4],\n        authors: [this.publicKey],\n        since: Math.floor(Date.now() / 1000) - 86400\n      }\n    ];\n\n    for (const relay of this.relays) {\n      relay.subscribe('barc-dms', filters, (event) => {\n        this.handleDMEvent(event);\n      });\n    }\n  }\n\n  async handleDMEvent(event) {\n    if (event.kind !== 4) return;\n\n    const isFromMe = event.pubkey === this.publicKey;\n    let otherPubkey;\n\n    if (isFromMe) {\n      const pTag = event.tags.find(t => t[0] === 'p');\n      if (!pTag) return;\n      otherPubkey = pTag[1];\n    } else {\n      otherPubkey = event.pubkey;\n    }\n\n    let plaintext;\n    try {\n      plaintext = await nip04Decrypt(this.privateKey, otherPubkey, event.content);\n    } catch (error) {\n      console.error('Failed to decrypt DM:', error);\n      return;\n    }\n\n    const dm = {\n      id: event.id,\n      pubkey: event.pubkey,\n      otherPubkey,\n      content: plaintext,\n      timestamp: event.created_at * 1000,\n      isOwn: isFromMe\n    };\n\n    if (!this.dmConversations.has(otherPubkey)) {\n      this.dmConversations.set(otherPubkey, []);\n    }\n    const conversation = this.dmConversations.get(otherPubkey);\n\n    if (!conversation.find(m => m.id === dm.id)) {\n      conversation.push(dm);\n      conversation.sort((a, b) => a.timestamp - b.timestamp);\n\n      if (this.dmCallback) {\n        this.dmCallback(dm, otherPubkey);\n      }\n    }\n  }\n\n  async sendDM(recipientPubkey, plaintext) {\n    if (!plaintext.trim()) return null;\n\n    const encryptedContent = await nip04Encrypt(this.privateKey, recipientPubkey, plaintext);\n\n    const event = await createEvent(\n      this.privateKey,\n      4,\n      encryptedContent,\n      [['p', recipientPubkey]]\n    );\n\n    let published = false;\n    for (const relay of this.relays) {\n      if (relay.publish(event)) {\n        published = true;\n      }\n    }\n\n    if (!published) {\n      console.error('sendDM: Failed to publish to any relay');\n      return null;\n    }\n\n    const dm = {\n      id: event.id,\n      pubkey: this.publicKey,\n      otherPubkey: recipientPubkey,\n      content: plaintext,\n      timestamp: event.created_at * 1000,\n      isOwn: true\n    };\n\n    if (!this.dmConversations.has(recipientPubkey)) {\n      this.dmConversations.set(recipientPubkey, []);\n    }\n    this.dmConversations.get(recipientPubkey).push(dm);\n\n    if (this.dmCallback) {\n      this.dmCallback(dm, recipientPubkey);\n    }\n\n    return event;\n  }\n\n  getDMConversation(pubkey) {\n    return this.dmConversations.get(pubkey) || [];\n  }\n\n  getDMConversations() {\n    const conversations = [];\n    for (const [pubkey, messages] of this.dmConversations) {\n      if (messages.length > 0) {\n        const lastMessage = messages[messages.length - 1];\n        conversations.push({\n          pubkey,\n          name: this.getUserName(pubkey),\n          lastMessage: lastMessage.content,\n          timestamp: lastMessage.timestamp,\n          unread: messages.filter(m => !m.isOwn && !m.read).length\n        });\n      }\n    }\n    return conversations.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  onDM(callback) {\n    this.dmCallback = callback;\n  }\n\n  subscribeToGlobalActivity() {\n    const filters = [\n      {\n        kinds: [10042],\n        since: Math.floor(Date.now() / 1000) - 300\n      }\n    ];\n\n    for (const relay of this.relays) {\n      relay.subscribe('barc-global', filters, (event) => {\n        this.handleGlobalPresence(event);\n      });\n    }\n  }\n\n  handleGlobalPresence(event) {\n    try {\n      const data = JSON.parse(event.content);\n      const url = data.url;\n      if (!url) return;\n\n      if (!this.globalActivity.has(url)) {\n        this.globalActivity.set(url, { users: new Map(), lastUpdate: 0 });\n      }\n\n      const activity = this.globalActivity.get(url);\n      activity.users.set(event.pubkey, {\n        name: data.name || event.pubkey.slice(0, 8),\n        lastSeen: event.created_at * 1000\n      });\n      activity.lastUpdate = Date.now();\n\n      if (this.globalActivityCallback) {\n        this.globalActivityCallback(this.getGlobalActivity());\n      }\n    } catch {}\n  }\n\n  getGlobalActivity() {\n    const now = Date.now();\n    const active = [];\n\n    for (const [url, activity] of this.globalActivity) {\n      let activeCount = 0;\n      const activeUsers = [];\n\n      for (const [pubkey, data] of activity.users) {\n        if (now - data.lastSeen < 300000) {\n          activeCount++;\n          activeUsers.push({\n            pubkey,\n            name: data.name,\n            isYou: pubkey === this.publicKey\n          });\n        }\n      }\n\n      if (activeCount > 0) {\n        active.push({\n          url,\n          userCount: activeCount,\n          users: activeUsers,\n          isCurrentPage: url === this.currentUrl\n        });\n      }\n    }\n\n    active.sort((a, b) => b.userCount - a.userCount);\n    return active;\n  }\n\n  onGlobalActivity(callback) {\n    this.globalActivityCallback = callback;\n  }\n\n  async joinChannel(url) {\n    this.currentUrl = url;\n    this.currentChannelId = await urlToChannelId(url);\n    this.pendingMessages = [];\n    this.seenMessageIds.clear();\n\n    console.log('Joining channel:', this.currentChannelId, 'for URL:', url);\n\n    const oneWeekAgo = Math.floor(Date.now() / 1000) - (7 * 24 * 60 * 60);\n    const filters = [\n      {\n        kinds: [42],\n        '#d': [this.currentChannelId],\n        since: oneWeekAgo,\n        limit: 10\n      },\n      {\n        kinds: [10042],\n        '#d': [this.currentChannelId],\n        since: Math.floor(Date.now() / 1000) - 300\n      }\n    ];\n    console.log('Subscribing with filters:', JSON.stringify(filters));\n\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      return { channelId: this.currentChannelId, messages: [] };\n    }\n\n    const eosePromise = new Promise((resolve) => {\n      let resolved = false;\n      const timeout = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          resolve();\n        }\n      }, 3000);\n\n      for (const relay of connectedRelays) {\n        relay.subscribe(`barc-${this.currentChannelId}`, filters, (event) => {\n          this.handleEvent(event, true);\n        }, () => {\n          if (!resolved) {\n            resolved = true;\n            clearTimeout(timeout);\n            resolve();\n          }\n        });\n      }\n    });\n\n    await eosePromise;\n\n    this.pendingMessages.sort((a, b) => a.timestamp - b.timestamp);\n    const messages = [...this.pendingMessages];\n    this.pendingMessages = [];\n\n    console.log('joinChannel: Got', messages.length, 'messages after EOSE');\n\n    await this.announcePresence();\n\n    return { channelId: this.currentChannelId, messages };\n  }\n\n  leaveChannel() {\n    if (this.currentChannelId) {\n      for (const relay of this.relays) {\n        relay.unsubscribe(`barc-${this.currentChannelId}`);\n      }\n      this.currentChannelId = null;\n      this.users.clear();\n    }\n  }\n\n  async fetchMessages(url, since = null, until = null, limit = 10) {\n    const channelId = await urlToChannelId(url);\n    const collectedMessages = [];\n    const seenIds = new Set();\n\n    const defaultSince = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);\n    const filter = {\n      kinds: [42],\n      '#d': [channelId],\n      since: since || defaultSince,\n      limit: limit\n    };\n\n    if (until) {\n      filter.until = until;\n    }\n\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      return [];\n    }\n\n    console.log('Fetching messages with filter:', filter);\n\n    const subId = `search-${Date.now()}`;\n\n    const eosePromise = new Promise((resolve) => {\n      let eoseCount = 0;\n      const timeout = setTimeout(() => {\n        console.log('Search timeout reached');\n        resolve();\n      }, 5000);\n\n      for (const relay of connectedRelays) {\n        relay.subscribe(subId, [filter], (event) => {\n          if (!seenIds.has(event.id)) {\n            seenIds.add(event.id);\n            const userName = this.getUserName(event.pubkey);\n            collectedMessages.push({\n              id: event.id,\n              pubkey: event.pubkey,\n              name: userName,\n              content: event.content,\n              timestamp: event.created_at * 1000,\n              isOwn: event.pubkey === this.publicKey\n            });\n          }\n        }, () => {\n          eoseCount++;\n          console.log(`EOSE from relay ${eoseCount}/${connectedRelays.length}`);\n          if (eoseCount >= connectedRelays.length) {\n            clearTimeout(timeout);\n            resolve();\n          }\n        });\n      }\n    });\n\n    await eosePromise;\n\n    for (const relay of connectedRelays) {\n      relay.unsubscribe(subId);\n    }\n\n    collectedMessages.sort((a, b) => a.timestamp - b.timestamp);\n\n    console.log(`Found ${collectedMessages.length} messages`);\n    return collectedMessages;\n  }\n\n  handleEvent(event, collecting = false) {\n    console.log('handleEvent received:', event.kind, event.id?.slice(0, 8), 'collecting:', collecting);\n\n    if (event.kind === 42) {\n      if (this.seenMessageIds.has(event.id)) return;\n      this.seenMessageIds.add(event.id);\n\n      const userName = this.getUserName(event.pubkey);\n      const message = {\n        id: event.id,\n        pubkey: event.pubkey,\n        name: userName,\n        content: event.content,\n        timestamp: event.created_at * 1000,\n        isOwn: event.pubkey === this.publicKey\n      };\n\n      if (collecting) {\n        this.pendingMessages.push(message);\n      } else if (this.messageCallback) {\n        this.messageCallback(message);\n      }\n    } else if (event.kind === 10042) {\n      try {\n        const data = JSON.parse(event.content);\n        this.users.set(event.pubkey, {\n          name: data.name || event.pubkey.slice(0, 8),\n          lastSeen: event.created_at * 1000\n        });\n        if (this.presenceCallback) {\n          this.presenceCallback(this.getActiveUsers());\n        }\n      } catch {}\n    }\n  }\n\n  getUserName(pubkey) {\n    const user = this.users.get(pubkey);\n    return user?.name || pubkey.slice(0, 8);\n  }\n\n  getActiveUsers() {\n    const now = Date.now();\n    const active = [];\n    for (const [pubkey, data] of this.users) {\n      if (now - data.lastSeen < 300000) {\n        active.push({\n          pubkey,\n          name: data.name,\n          isYou: pubkey === this.publicKey\n        });\n      }\n    }\n    return active;\n  }\n\n  async announcePresence(name = null) {\n    if (!this.currentChannelId || !this.publicKey) return;\n\n    const displayName = name || `User-${this.publicKey.slice(0, 6)}`;\n\n    const content = JSON.stringify({\n      name: displayName,\n      url: this.currentUrl,\n      action: 'join'\n    });\n\n    const event = await createEvent(\n      this.privateKey,\n      10042,\n      content,\n      [['d', this.currentChannelId]]\n    );\n\n    for (const relay of this.relays) {\n      relay.publish(event);\n    }\n\n    this.users.set(this.publicKey, {\n      name: displayName,\n      lastSeen: Date.now()\n    });\n\n    if (this.currentUrl) {\n      if (!this.globalActivity.has(this.currentUrl)) {\n        this.globalActivity.set(this.currentUrl, { users: new Map(), lastUpdate: 0 });\n      }\n      const activity = this.globalActivity.get(this.currentUrl);\n      activity.users.set(this.publicKey, {\n        name: displayName,\n        lastSeen: Date.now()\n      });\n    }\n  }\n\n  async sendMessage(content, url = null) {\n    // Use provided URL or fall back to current channel\n    const channelId = url ? await urlToChannelId(url) : this.currentChannelId;\n\n    console.log('sendMessage: url=', url, 'channelId=', channelId, 'currentChannelId=', this.currentChannelId);\n\n    if (!channelId || !content.trim()) {\n      console.error('sendMessage: No channel or empty content');\n      return null;\n    }\n\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      console.error('sendMessage: No relays connected');\n      return null;\n    }\n\n    const event = await createEvent(\n      this.privateKey,\n      42,\n      content,\n      [['d', channelId]]\n    );\n\n    let published = false;\n    for (const relay of connectedRelays) {\n      if (relay.publish(event)) {\n        published = true;\n      }\n    }\n\n    if (!published) {\n      console.error('sendMessage: Failed to publish to any relay');\n      return null;\n    }\n\n    if (this.messageCallback) {\n      this.messageCallback({\n        id: event.id,\n        pubkey: event.pubkey,\n        name: this.getUserName(event.pubkey),\n        content: event.content,\n        timestamp: event.created_at * 1000,\n        isOwn: true\n      });\n    }\n\n    return event;\n  }\n\n  onMessage(callback) {\n    this.messageCallback = callback;\n  }\n\n  onPresence(callback) {\n    this.presenceCallback = callback;\n  }\n\n  // Post to someone's wall (HomeScreen) - uses p-tag to reference the wall owner\n  // This is a bare-bones post to a pubkey address\n  async postToWall(targetPubkey, content) {\n    if (!content.trim()) {\n      console.error('postToWall: Empty content');\n      return null;\n    }\n\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      console.error('postToWall: No relays connected');\n      return null;\n    }\n\n    // Use kind 1 (short text note) with p-tag pointing to the wall owner\n    // This keeps it as simple as possible while still being addressable\n    const event = await createEvent(\n      this.privateKey,\n      1, // Standard text note\n      content,\n      [\n        ['p', targetPubkey], // Reference to whose wall this is on\n        ['barc-wall', targetPubkey] // Custom tag to identify wall posts\n      ]\n    );\n\n    let published = false;\n    for (const relay of connectedRelays) {\n      if (relay.publish(event)) {\n        published = true;\n      }\n    }\n\n    if (!published) {\n      console.error('postToWall: Failed to publish to any relay');\n      return null;\n    }\n\n    return event;\n  }\n\n  // Fetch posts that mention/tag a pubkey (from other users)\n  async fetchMentions(targetPubkey, limit = 50) {\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      return [];\n    }\n\n    const posts = [];\n    const seenIds = new Set();\n\n    // Query for events that tag this pubkey (NIP-01 p-tag)\n    // Common kinds: 1 (text note), 6 (repost), 7 (reaction), 9735 (zap receipt)\n    const filter = {\n      kinds: [1, 6, 7, 9735],\n      '#p': [targetPubkey],\n      limit\n    };\n\n    const fetchPromises = connectedRelays.map(relay => {\n      return new Promise((resolve) => {\n        const timeout = setTimeout(() => resolve(), 5000);\n\n        relay.subscribe(filter, (event) => {\n          if (!seenIds.has(event.id)) {\n            seenIds.add(event.id);\n            posts.push(this.parseEventToPost(event));\n          }\n        }, () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n      });\n    });\n\n    await Promise.all(fetchPromises);\n\n    // Sort by timestamp descending (newest first)\n    posts.sort((a, b) => b.timestamp - a.timestamp);\n\n    return posts;\n  }\n\n  // Fetch posts authored by a pubkey (their own posts)\n  async fetchUserPosts(targetPubkey, limit = 50) {\n    const connectedRelays = this.relays.filter(r => r.connected);\n    if (connectedRelays.length === 0) {\n      return [];\n    }\n\n    const posts = [];\n    const seenIds = new Set();\n\n    // Query for events authored by this pubkey\n    // Common kinds: 1 (text note), 6 (repost), 30023 (long-form)\n    const filter = {\n      kinds: [1, 6, 30023],\n      authors: [targetPubkey],\n      limit\n    };\n\n    const fetchPromises = connectedRelays.map(relay => {\n      return new Promise((resolve) => {\n        const timeout = setTimeout(() => resolve(), 5000);\n\n        relay.subscribe(filter, (event) => {\n          if (!seenIds.has(event.id)) {\n            seenIds.add(event.id);\n            posts.push(this.parseEventToPost(event));\n          }\n        }, () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n      });\n    });\n\n    await Promise.all(fetchPromises);\n\n    // Sort by timestamp descending (newest first)\n    posts.sort((a, b) => b.timestamp - a.timestamp);\n\n    return posts;\n  }\n\n  // Parse a raw Nostr event into a structured post object\n  parseEventToPost(event) {\n    const post = {\n      id: event.id,\n      pubkey: event.pubkey,\n      name: this.getUserName(event.pubkey),\n      content: event.content,\n      timestamp: event.created_at * 1000,\n      kind: event.kind,\n      kindLabel: this.getKindLabel(event.kind),\n      tags: event.tags,\n      isOwn: event.pubkey === this.publicKey,\n      images: [],\n      links: [],\n      mentionedPubkeys: []\n    };\n\n    // Extract images from content (common image URLs)\n    const imageRegex = /(https?:\\/\\/[^\\s]+\\.(?:jpg|jpeg|png|gif|webp))/gi;\n    const imageMatches = event.content.match(imageRegex);\n    if (imageMatches) {\n      post.images = [...new Set(imageMatches)];\n    }\n\n    // Extract links from content\n    const linkRegex = /(https?:\\/\\/[^\\s]+)/gi;\n    const linkMatches = event.content.match(linkRegex);\n    if (linkMatches) {\n      post.links = [...new Set(linkMatches)].filter(l => !post.images.includes(l));\n    }\n\n    // Extract mentioned pubkeys from p-tags\n    for (const tag of event.tags) {\n      if (tag[0] === 'p' && tag[1]) {\n        post.mentionedPubkeys.push(tag[1]);\n      }\n    }\n\n    // For reposts (kind 6), the content might be the original event JSON\n    if (event.kind === 6 && event.content) {\n      try {\n        const originalEvent = JSON.parse(event.content);\n        post.repostedEvent = this.parseEventToPost(originalEvent);\n      } catch {\n        // Content isn't valid JSON, just use as is\n      }\n    }\n\n    // For reactions (kind 7), content is the reaction emoji\n    if (event.kind === 7) {\n      post.reaction = event.content || '+';\n      // Find what event they're reacting to\n      for (const tag of event.tags) {\n        if (tag[0] === 'e' && tag[1]) {\n          post.reactedToEventId = tag[1];\n          break;\n        }\n      }\n    }\n\n    // For zap receipts (kind 9735), extract amount\n    if (event.kind === 9735) {\n      for (const tag of event.tags) {\n        if (tag[0] === 'bolt11' && tag[1]) {\n          // Basic extraction of amount from bolt11 invoice\n          post.zapInvoice = tag[1];\n        }\n        if (tag[0] === 'description' && tag[1]) {\n          try {\n            const zapRequest = JSON.parse(tag[1]);\n            post.zapMessage = zapRequest.content;\n          } catch {\n            // Not valid JSON\n          }\n        }\n      }\n    }\n\n    return post;\n  }\n\n  // Get human-readable label for event kind\n  getKindLabel(kind) {\n    const kinds = {\n      1: 'note',\n      6: 'repost',\n      7: 'reaction',\n      9735: 'zap',\n      30023: 'article'\n    };\n    return kinds[kind] || `kind ${kind}`;\n  }\n\n  // Keep old method for backwards compatibility\n  async fetchWallPosts(targetPubkey, limit = 50) {\n    return this.fetchMentions(targetPubkey, limit);\n  }\n\n  disconnect() {\n    this.leaveChannel();\n    for (const relay of this.relays) {\n      relay.close();\n    }\n    this.relays = [];\n  }\n}\n\n// Export for use in extension\nexport { BarcNostrClient, generatePrivateKey, getPublicKey, DEFAULT_RELAYS };\n", "// Background service worker for Barc\n// Manages Nostr connections and coordinates with dashboard\n\nimport { BarcNostrClient, generatePrivateKey, getPublicKey } from './lib/nostr.js';\n\nlet nostrClient = null;\nlet currentChannelUrl = null; // URL of the channel we're currently joined to\nlet userName = null;\nlet unreadCount = 0;\nlet dashboardOpen = false;\n\n// Bech32 decoding for nsec keys\nconst BECH32_ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n\nfunction bech32Decode(str) {\n  str = str.toLowerCase();\n  const sepIndex = str.lastIndexOf('1');\n  if (sepIndex < 1) return null;\n\n  const hrp = str.slice(0, sepIndex);\n  const data = str.slice(sepIndex + 1);\n\n  const values = [];\n  for (const char of data) {\n    const idx = BECH32_ALPHABET.indexOf(char);\n    if (idx === -1) return null;\n    values.push(idx);\n  }\n\n  // Remove checksum (last 6 characters)\n  const payload = values.slice(0, -6);\n\n  // Convert 5-bit groups to 8-bit bytes\n  let acc = 0;\n  let bits = 0;\n  const result = [];\n\n  for (const value of payload) {\n    acc = (acc << 5) | value;\n    bits += 5;\n    while (bits >= 8) {\n      bits -= 8;\n      result.push((acc >> bits) & 0xff);\n    }\n  }\n\n  return { hrp, bytes: new Uint8Array(result) };\n}\n\nfunction bytesToHex(bytes) {\n  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n// Parse key input - supports nsec1... or hex format\nfunction parsePrivateKey(input) {\n  input = input.trim();\n\n  // Check for nsec bech32 format\n  if (input.startsWith('nsec1')) {\n    const decoded = bech32Decode(input);\n    if (!decoded || decoded.hrp !== 'nsec' || decoded.bytes.length !== 32) {\n      return { error: 'Invalid nsec key format' };\n    }\n    return { privateKey: bytesToHex(decoded.bytes) };\n  }\n\n  // Check for hex format (64 chars)\n  if (/^[a-fA-F0-9]{64}$/.test(input)) {\n    return { privateKey: input.toLowerCase() };\n  }\n\n  return { error: 'Invalid key format. Use nsec1... or 64-char hex.' };\n}\n\n// Update the extension badge\nfunction updateBadge() {\n  if (unreadCount > 0) {\n    chrome.action.setBadgeText({ text: unreadCount > 99 ? '99+' : unreadCount.toString() });\n    chrome.action.setBadgeBackgroundColor({ color: '#e94560' });\n  } else {\n    // Show user count if no unread messages\n    const userCount = nostrClient?.getActiveUsers()?.length || 0;\n    if (userCount > 0) {\n      chrome.action.setBadgeText({ text: userCount.toString() });\n      chrome.action.setBadgeBackgroundColor({ color: '#4ade80' });\n    } else {\n      chrome.action.setBadgeText({ text: '' });\n    }\n  }\n}\n\n// Clear unread count\nfunction clearUnread() {\n  unreadCount = 0;\n  updateBadge();\n}\n\n// Initialize the Nostr client with an existing key\nasync function initClient(privateKey = null) {\n  // If we have a fully initialized client and no new key, return existing\n  if (nostrClient && nostrClient.publicKey && !privateKey) return nostrClient;\n\n  // If reinitializing with new key, disconnect first\n  if (nostrClient && privateKey) {\n    nostrClient.disconnect();\n    nostrClient = null;\n  }\n\n  // Load saved keys and username\n  const stored = await chrome.storage.local.get(['privateKey', 'userName']);\n  userName = stored.userName || null;\n\n  // Use provided key, or stored key\n  const keyToUse = privateKey || stored.privateKey;\n\n  if (!keyToUse) {\n    // No key yet - don't auto-generate, wait for user action\n    return null;\n  }\n\n  // Create and initialize client\n  nostrClient = new BarcNostrClient();\n  await nostrClient.init(keyToUse);\n\n  // Save the key if it was newly provided\n  if (privateKey && privateKey !== stored.privateKey) {\n    await chrome.storage.local.set({ privateKey });\n  }\n\n  // Set up event handlers\n  nostrClient.onMessage((msg) => {\n    // Increment unread count if dashboard is closed and message isn't ours\n    if (!dashboardOpen && !msg.isOwn) {\n      unreadCount++;\n      updateBadge();\n    }\n    broadcastToAll({ type: 'NEW_MESSAGE', message: msg, url: currentChannelUrl });\n  });\n\n  nostrClient.onPresence((users) => {\n    updateBadge();\n    broadcastToAll({ type: 'PRESENCE_UPDATE', users, url: currentChannelUrl });\n  });\n\n  nostrClient.onGlobalActivity((activity) => {\n    broadcastToAll({ type: 'GLOBAL_ACTIVITY', activity });\n  });\n\n  nostrClient.onDM((dm, otherPubkey) => {\n    // Increment unread if dashboard closed and not our own message\n    if (!dashboardOpen && !dm.isOwn) {\n      unreadCount++;\n      updateBadge();\n    }\n    broadcastToAll({ type: 'NEW_DM', dm, otherPubkey });\n  });\n\n  return nostrClient;\n}\n\n// Join channel for a specific URL\nasync function joinChannel(url) {\n  if (!url || url.startsWith('chrome://') || url.startsWith('chrome-extension://')) {\n    return { messages: [], users: [] };\n  }\n\n  const client = await initClient();\n  if (!client) return { messages: [], users: [] }; // No key configured yet\n\n  // Leave previous channel if different URL\n  if (currentChannelUrl && currentChannelUrl !== url) {\n    client.leaveChannel();\n  }\n\n  currentChannelUrl = url;\n  const result = await client.joinChannel(url);\n\n  if (userName) {\n    await client.announcePresence(userName);\n  }\n\n  updateBadge();\n\n  return {\n    messages: result?.messages || [],\n    users: client.getActiveUsers() || []\n  };\n}\n\n// Broadcast message to all extension pages (dashboard)\nasync function broadcastToAll(message) {\n  chrome.runtime.sendMessage(message).catch(() => {});\n}\n\n// Open dashboard tab when extension icon is clicked\nchrome.action.onClicked.addListener(async () => {\n  // Check if dashboard is already open\n  const dashboardUrl = chrome.runtime.getURL('src/ui/dashboard.html');\n  const tabs = await chrome.tabs.query({ url: dashboardUrl });\n\n  if (tabs.length > 0) {\n    // Focus existing dashboard tab\n    chrome.tabs.update(tabs[0].id, { active: true });\n    chrome.windows.update(tabs[0].windowId, { focused: true });\n  } else {\n    // Open new dashboard tab\n    chrome.tabs.create({ url: dashboardUrl });\n  }\n});\n\n// Handle messages from dashboard\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  handleMessage(request, sender).then(sendResponse);\n  return true; // Keep channel open for async response\n});\n\nasync function handleMessage(request, sender) {\n  switch (request.type) {\n    case 'INIT': {\n      const client = await initClient();\n      return {\n        publicKey: client?.publicKey || null,\n        userName: userName\n      };\n    }\n\n    case 'DASHBOARD_OPENED': {\n      dashboardOpen = true;\n      clearUnread();\n      return { success: true };\n    }\n\n    case 'GENERATE_KEY': {\n      try {\n        const privateKey = generatePrivateKey();\n        const publicKey = getPublicKey(privateKey);\n\n        // Save the new key\n        await chrome.storage.local.set({ privateKey });\n\n        // Initialize client with new key\n        await initClient(privateKey);\n\n        return { success: true, publicKey };\n      } catch (error) {\n        return { success: false, error: error.message };\n      }\n    }\n\n    case 'IMPORT_KEY': {\n      const parsed = parsePrivateKey(request.key);\n      if (parsed.error) {\n        return { success: false, error: parsed.error };\n      }\n\n      try {\n        const publicKey = getPublicKey(parsed.privateKey);\n\n        // Save the imported key\n        await chrome.storage.local.set({ privateKey: parsed.privateKey });\n\n        // Initialize client with imported key\n        await initClient(parsed.privateKey);\n\n        return { success: true, publicKey };\n      } catch (error) {\n        return { success: false, error: 'Invalid private key' };\n      }\n    }\n\n    case 'JOIN_TAB_CHANNEL': {\n      const result = await joinChannel(request.url);\n      return result;\n    }\n\n    case 'SEND_MESSAGE': {\n      if (!nostrClient) {\n        return { error: 'Not connected' };\n      }\n      // If url is provided, use it (for profile walls), otherwise use current channel\n      const targetUrl = request.url || currentChannelUrl;\n      const event = await nostrClient.sendMessage(request.content, targetUrl);\n      return { success: !!event, eventId: event?.id };\n    }\n\n    case 'POST_TO_WALL': {\n      if (!nostrClient) {\n        return { error: 'Not connected' };\n      }\n      // Post to someone's wall using their pubkey as the address\n      const event = await nostrClient.postToWall(request.targetPubkey, request.content);\n      return { success: !!event, eventId: event?.id };\n    }\n\n    case 'FETCH_WALL_POSTS': {\n      if (!nostrClient) {\n        return { posts: [], error: 'Not connected' };\n      }\n      try {\n        const posts = await nostrClient.fetchWallPosts(request.targetPubkey, request.limit || 50);\n        return { posts };\n      } catch (error) {\n        console.error('Failed to fetch wall posts:', error);\n        return { posts: [], error: error.message };\n      }\n    }\n\n    case 'FETCH_MENTIONS': {\n      if (!nostrClient) {\n        return { posts: [], error: 'Not connected' };\n      }\n      try {\n        const posts = await nostrClient.fetchMentions(request.targetPubkey, request.limit || 50);\n        return { posts };\n      } catch (error) {\n        console.error('Failed to fetch mentions:', error);\n        return { posts: [], error: error.message };\n      }\n    }\n\n    case 'FETCH_USER_POSTS': {\n      if (!nostrClient) {\n        return { posts: [], error: 'Not connected' };\n      }\n      try {\n        const posts = await nostrClient.fetchUserPosts(request.targetPubkey, request.limit || 50);\n        return { posts };\n      } catch (error) {\n        console.error('Failed to fetch user posts:', error);\n        return { posts: [], error: error.message };\n      }\n    }\n\n    case 'SEND_DM': {\n      if (!nostrClient) {\n        return { error: 'Not connected' };\n      }\n      const event = await nostrClient.sendDM(request.recipientPubkey, request.content);\n      return { success: !!event, eventId: event?.id };\n    }\n\n    case 'GET_DM_CONVERSATIONS': {\n      return {\n        conversations: nostrClient?.getDMConversations() || []\n      };\n    }\n\n    case 'GET_DM_CONVERSATION': {\n      return {\n        messages: nostrClient?.getDMConversation(request.pubkey) || []\n      };\n    }\n\n    case 'SET_USERNAME': {\n      userName = request.name;\n      await chrome.storage.local.set({ userName });\n      if (nostrClient && nostrClient.currentChannelId) {\n        await nostrClient.announcePresence(userName);\n      }\n      return { success: true };\n    }\n\n    case 'GET_STATUS': {\n      return {\n        connected: nostrClient?.relays.some(r => r.connected) || false,\n        channelId: nostrClient?.currentChannelId || null,\n        url: currentChannelUrl,\n        users: nostrClient?.getActiveUsers() || [],\n        publicKey: nostrClient?.publicKey || null,\n        unreadCount: unreadCount,\n        globalActivity: nostrClient?.getGlobalActivity() || []\n      };\n    }\n\n    case 'GET_GLOBAL_ACTIVITY': {\n      return {\n        activity: nostrClient?.getGlobalActivity() || []\n      };\n    }\n\n    case 'GET_ALL_TAB_COUNTS': {\n      // Get user counts for all URLs from global activity\n      const counts = {};\n      const activity = nostrClient?.getGlobalActivity() || [];\n      for (const item of activity) {\n        counts[item.url] = item.userCount;\n      }\n      return { counts };\n    }\n\n    case 'FETCH_MESSAGES': {\n      if (!nostrClient) {\n        return { messages: [], error: 'Not connected' };\n      }\n      try {\n        const messages = await nostrClient.fetchMessages(\n          request.url,\n          request.since,\n          request.until,\n          request.limit\n        );\n        return { messages };\n      } catch (error) {\n        console.error('Failed to fetch messages:', error);\n        return { messages: [], error: error.message };\n      }\n    }\n\n    default:\n      return { error: 'Unknown message type' };\n  }\n}\n\n// Initialize client on startup\nchrome.runtime.onStartup.addListener(async () => {\n  await initClient();\n});\n\n// Also init when extension is installed/updated\nchrome.runtime.onInstalled.addListener(async () => {\n  await initClient();\n});\n\n// Keep service worker alive with periodic alarm\nchrome.alarms.create('keepAlive', { periodInMinutes: 1 });\n\nchrome.alarms.onAlarm.addListener((alarm) => {\n  if (alarm.name === 'keepAlive' && nostrClient?.currentChannelId) {\n    // Send presence update\n    nostrClient.announcePresence(userName);\n    updateBadge();\n  }\n});\n"],
  "mappings": "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",
  "names": ["getPublicKey", "x", "y", "isEven", "crypto", "isBytes", "abytes", "lengths", "bytesToHex", "abytes", "hexToBytes", "abytes", "randomBytes", "crypto", "abytes", "C", "G", "sha256", "abytes", "sha256", "bytesToHex", "randomBytes", "getPublicKey", "hexToBytes", "getPublicKey", "hexToBytes", "bytesToHex", "getPublicKey", "userName", "bytesToHex", "getPublicKey"]
}
